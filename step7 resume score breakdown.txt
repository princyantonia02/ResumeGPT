import streamlit as st
import PyPDF2
import io
import os
import requests
from dotenv import load_dotenv
from services.matcher import compute_match
from services.skill_extractor import compute_skill_gap
from services.skills_list import SKILL_LIST
from services.matcher import explain_match, simulate_improvement




# ---------------- Load env ----------------
load_dotenv()
HF_API_KEY = os.getenv("HUGGINGFACE_API_KEY")
API_URL = "https://router.huggingface.co/v1/chat/completions"
HEADERS = {
    "Authorization": f"Bearer {HF_API_KEY}",
    "Content-Type": "application/json"
}

if not HF_API_KEY:
    st.error("HUGGINGFACE_API_KEY not found in .env")
    st.stop()

# ---------------- Streamlit UI ----------------
st.set_page_config(page_title="Smart Resume Feedback", layout="centered")
st.title("üöÄ Smart Resume Feedback Generator")

uploaded_file = st.file_uploader("Upload resume (PDF/TXT)", type=["pdf", "txt"])
job_role = st.text_input("Target job role (optional)")
st.subheader("üìå Job Description (Optional)")
job_description = st.text_area(
    "Paste the job description to get resume‚ÄìJD matching insights",
    height=200,
    placeholder="Example: Looking for a Data Scientist with Python, SQL, ML, and data visualization skills..."
)

job_description = job_description.strip()
jd_provided = len(job_description) > 0
analyze = st.button("Generate Feedback üìù")

# ---------------- Helpers ----------------
def extract_text_from_pdf(file):
    reader = PyPDF2.PdfReader(file)
    return "\n".join([p.extract_text() or "" for p in reader.pages])

def extract_text(file):
    if file.type == "application/pdf":
        return extract_text_from_pdf(io.BytesIO(file.read()))
    return file.read().decode("utf-8")

def query_hf(prompt):
    payload = {
        "model": "deepseek-ai/DeepSeek-R1",
        "messages": [{"role": "user", "content": prompt}]
    }
    response = requests.post(API_URL, headers=HEADERS, json=payload, timeout=120)
    if response.status_code != 200:
        st.error(f"HTTP Error {response.status_code}: {response.text}")
        return ""
    return response.json()["choices"][0]["message"]["content"]

# ---------------- Main Logic ----------------
if analyze and uploaded_file:
    resume_text = extract_text(uploaded_file)
        

    if not resume_text.strip():
        st.error("‚ùå Could not extract text from resume.")
        st.stop()
    match_score = None
    matched_keywords = []
    missing_keywords = []
    

    if jd_provided:
        match_score, matched_keywords, missing_keywords = compute_match(
            resume_text, job_description
        )
        
        st.subheader("üìä Resume‚ÄìJob Match")

        st.metric("Match Score", f"{match_score}%")

        col1, col2 = st.columns(2)

        with col1:
            st.markdown("**‚úÖ Matched Keywords**")
            for kw in matched_keywords:
                st.write(f"‚Ä¢ {kw}")

        with col2:
            st.markdown("**‚ùå Missing Keywords**")
            for kw in missing_keywords:
                st.write(f"‚Ä¢ {kw}")

    if jd_provided:
        matched, missing, extra = compute_skill_gap(resume_text, job_description, SKILL_LIST)

        st.subheader("üìä Skill Gap Analysis")
        st.write("This shows which skills you have ‚úÖ, which are missing ‚ùå, and extras üü¢.")

        import pandas as pd
        df = pd.DataFrame(
            [{"Skill": s, "Status": "‚úÖ In Resume & JD"} for s in matched] +
            [{"Skill": s, "Status": "‚ùå Missing in Resume"} for s in missing] +
            [{"Skill": s, "Status": "üü¢ Extra in Resume"} for s in extra]
        )

        st.table(df)
        # ---------------- Explainable AI ----------------
    if jd_provided:
        explanations = explain_match(matched_keywords, missing_keywords)
        improved_score = simulate_improvement(match_score, missing_keywords)

        st.subheader("üß† Why This Score?")

        for e in explanations:
            st.write(e)

        st.subheader("üöÄ Improvement Simulation")
        st.write(
            f"If you focus on the missing high-impact skills, your match score could improve from "
            f"**{match_score}% ‚Üí {improved_score}%**."
        )
    

    if jd_provided:
        st.subheader("üìä Resume Score Breakdown")

        skills_weight = 0.4
        keywords_weight = 0.3
        experience_weight = 0.2
        formatting_weight = 0.1

        # Scale based on actual match_score
        skills_score = round(match_score * skills_weight)
        keywords_score = round(match_score * keywords_weight)
        experience_score = round(match_score * experience_weight)
        formatting_score = round(match_score * formatting_weight)

        breakdown_data = {
            "Category": ["Skills Match", "Keywords", "Experience Relevance", "Formatting"],
            "Score (%)": [skills_score, keywords_score, experience_score, formatting_score]
        }

        import pandas as pd
        breakdown_df = pd.DataFrame(breakdown_data)

        st.table(breakdown_df)




    prompt = f"""
Analyze the following resume and provide **concise, scannable feedback in 5 lines**.

Start with a **5‚Äì7 line summary only** highlighting key strengths and overall observations about the resume content.

Then organize feedback under bold headings with emojis. For each heading, provide 2‚Äì6 bullet points based on the resume. Focus on these areas:

üéØ Clarity & Impact
‚öôÔ∏è Skills Relevance
üìÑ Structure & Formatting
‚ú® Improvements / Recommendations

Do not mention dates or do not pretent any reference to acting as an HR recruiter. Keep the feedback **easy to read, actionable, and visually structured**.
Resume:
{resume_text}
"""

    with st.spinner("Analyzing resume..."):
        feedback = query_hf(prompt)

    # ---------------- Display ----------------
    st.markdown(
        f"<div style='font-size:16px; line-height:1.5'>{feedback}</div>",
        unsafe_allow_html=True
    )
